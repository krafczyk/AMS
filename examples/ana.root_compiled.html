<HTML>
<BODY>
<CENTER>
<hr>
<H1> <font color=red> `Compiled' Analysis </font> </H1>
<hr>
</CENTER>
<p> The <a href="http://root.cern.ch/root/html/TSelector.html#TSelector:description"> 
TSelector </a> class is 
used by the method 
<a href="http://root.cern.ch/root/html/TTree.html#TTree:Process">           
"TTree::Process" </a> in order to loop over 
TTree events and to make selections. TSelector contains the following methods:<br>

<table align=center>
  <tr>
   <td> <b>void Begin(TTree *tree): </b> </td>
   <td> Called at initialization</td>
  </tr>
  <tr>
   <td> <b>Bool_t ProcessCut(int entry): </b> </td>
   <td> Called before an entry is read (here one can decide if the 
        event entry must be fully read or not) </td>
  </tr>
  <tr>
   <td> <b>void ProcessFill(int entry): </b> </td>
   <td> Called for each event entry (here one should do the 
        event by event analysis) </td>
  </tr>
  <tr>
   <td> <b>void Terminate(): </b> </td>
   <td> Called at the end of the event loop (to draw, close and finalize
        operations) </td>
  </tr>
</table>
<br>

     There is a specific implementation of this logic in the AMS code. 
The main class, AMSEventR, inheriting all the TSelector functionality, 
is created as "class AMSEventR: public TSelector {...}".
The relevant features of the AMS implementation are:<br>

<ul>
   <li> The Begin(TTree* tree), ProcessCut(int entry), ProcessFill(int entry)
         and Terminate() methods are implemented
        in AMSEventR as methods that perform several operations and then call respectively:<br>
<table align=center>
  <tr>
   <td> <b>void UBegin() </b> </td>
  </tr>
  <tr>
   <td> <b>bool UProcessCut() </b> </td>
  </tr>
  <tr>
   <td> <b>void UProcessFill() </b> </td>
  </tr>
  <tr>
   <td> <b>void UTerminate() </b> </td>
  </tr>
</table>
<br>
        (note that the "int entry" and "TTree *tree" arguments have been dropped).  
        The intention is to have users calling UBegin(), 
        UProcessCut(), UProcessFill() and UTerminate() 
        in their analysis (and not Begin(tree), ProcessCut(entry),...).
        <br>
</ul>
<ul>
   <li> Using UProcessCut() is optional and it is included just for 
        convenience.  There is no gain in time by calling it. 
        The AMS implementation reads a header, not the full information. 
        The idea is that, since all information is "directly" accessed by 
        pointers, we are only spending time when we actually "pick up" the 
        contents inside UProcessFill().<br>
</ul>
<ul>
   <li> All the necessary definitions are in the AMS Root header file, 
        either "/offline/vdev/include/root.h" or "$AMSDir/include/root.h". 
        This header file must be always included in your analysis program.
</ul>
<ul>
   <li> In order to access in a simple way all relevant pieces of information 
        many useful definitions, via pointers and vectors, are implemented. For example, 
        the number of hits in ECAL is given by::<br>
             <center> <b> 
             cout << "#Ehits: " << nEcalHit() << endl; 
             </b> </center><br>
        The "i" Hit in ECAL belongs to the class EcalHitR, and it may be
        accessed either as:<br>
             <center> <b> EcalHitR hit = EcalHit(i); </b> </center><br>
        or via the pointer pEcalHit(i):<br>
             <center> <b> EcalHitR* phit = pEcalHit(i); </b> </center><br>
        A reference to the ith element is obtained as:
             <center> <b> EcalHitR* phit = &EcalHit(i); </b> </center><br>
        The full list of AMS classes and attributes can be found 
        <a href="http://ams.cern.ch/AMS/Analysis/hpl3itp1/root02/html/classes.html"> 
        HERE </a>. For instance, in 
        <a href="http://ams.cern.ch/AMS/Analysis/hpl3itp1/root02/html/classEcalHitR.html"> 
        EcalHitR </a> the first member is "Status", which can be accessed either as:<br>
             <center> <b> int stat = EcalHit(i).Status; </b> </center><br><br>
        or:
             <center> <b> int stat = pEcalHit(i)->Status; </b> </center><br><br>
</ul>

<p> Let us go to practice. To analyze AMS data with `compiled' code one needs two 
programs: a `steering' program and the `to-be-compiled' analysis program. An example of steering program is 
<a href="http://ams.cern.ch/AMS/Analysis/hpl3itp1/root02/html/run_8stlv_8C-source.html">
 run.stlv.C </a>, which will initialize some ROOT stuff, define input and output files 
and invoque "TTree::Process". An example of the 
actual 'analysis' program, containing the "real" stuff with the calls to
Ubegin(), UProcessCut(), UProcessFill() and UTerminate(), 
is <a href="http://ams.cern.ch/AMS/Analysis/hpl3itp1/root02/html/stlv_8C-source.html">
stlv.C </a>. Everything works together by doing "root run.stlv.C". If one wants to run in 
non-graphic mode and exiting root at the end of processing, do: "root -b -q run.stlv.C".

   Some final comments:

<ul>
   <li> Note that the "stlv" name is not mandatory. Everything will work equally well if 
        you change all "stlv" by "anything". For instance, you may want to write 
        "my_anal.C", "class my_anal" and "chain.Process("my_anal.C+")" where appropriate.
</ul>
<ul>
   <li> It is recommended to include in "stlv.C" a "root.h" file which 
        matches the "ntuple.so" library loaded in "run.stlv.C". In case
        of doubts, you may want to create your own "$AMSDir/lib/linux/icc/ntuple.so" library with 
        "cd $AMSDir/install; gmake shared" and include "$AMSDir/include/root.h".
</ul>
<ul>
   <li> If you are combining several Root files created with different versions of the 
        AMS code, try to use the latest versions for "ntuple.so" and "root.h" and, of 
        course, do not extract a given variable if it does not exist for some of the Root files. 
        ROOT is able to work consistently in the presence of different versions, 
        although it may give problems whenever "ntuple.so" and 
        "root.h" are older than the newest of the structure versions in your files.
</ul>

</BODY>
</HTML>
