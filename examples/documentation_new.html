<HTML>
<BODY>
<CENTER>
<hr>
<H1> <font color=red> INTRODUCTION </font> </H1>
</CENTER>
  <p> The standard AMS reconstruction output is a 
<a href="http://root.cern.ch"> ROOT </a> file, in which
<a href="http://root.cern.ch/root/html/TTree.html#TTree:description"> 
TTree </a> event structures are built. 

  These data can be analyzed using C++ code in two ways:

<ul>
      <li> By "compiling" the code with the 
           <a href="http://root.cern.ch/root/html/TTree.html#TTree:Process">           
           "TTree::Process" </a> method implemented in ROOT. 
           We will denote this approach by the term COMPILED. This is the optimal 
           approach for big data samples, for which execution time counts.
</ul>

<ul>
      <li> By "interpreting" the code with the 
           <a href="http://root.cern.ch/root/Cint.html"> 
           CINT </a> ROOT interpreter. We will 
           denote this approach by the term INTERACTIVE. This is probably a 
           good approach for small/medium data size samples, for which 
           compiling time &gt;&gt; execution time.
</ul>

<p> Both approaches are briefly described in the following lines. In addition,
you can also analyze AMS data via <a href="http://www.python.org"> PYTHON </a> and 
<a href="http://www.ruby-lang.org"> RUBY </a> scripting languages. You can 
find more information in the links
<a href="http://ams.cern.ch/AMS/Analysis/hpl3itp1/root02/html/ana_8root__python_8doc-example.html">
ana_root_python.doc </a> and
<a href="http://ams.cern.ch/AMS/Analysis/hpl3itp1/root02/html/ana_8root__ruby_8doc-example.html">
ana_root_ruby.doc </a>.

<CENTER>
<H2> <font color=red> `Compiled' Analysis </font> </H2>
</CENTER>
<p> The <a href="http://root.cern.ch/root/html/TSelector.html#TSelector:description"> 
TSelector </a> class is 
used by the method 
<a href="http://root.cern.ch/root/html/TTree.html#TTree:Process">           
"TTree::Process" </a> in order to loop over 
TTree events and to make selections. TSelector contains the following methods:<br>

<table align=center>
  <tr>
   <td> <b>void Begin(TTree *tree): </b> </td>
   <td> Called at initialization</td>
  </tr>
  <tr>
   <td> <b>Bool_t ProcessCut(int entry): </b> </td>
   <td> Called before an entry is read (here one can decide if the 
        event entry must be fully read or not) </td>
  </tr>
  <tr>
   <td> <b>void ProcessFill(int entry): </b> </td>
   <td> Called for each event entry (here one should do the 
        event by event analysis) </td>
  </tr>
  <tr>
   <td> <b>void Terminate(): </b> </td>
   <td> Called at the end of the event loop (to draw, close and finalize
        operations) </td>
  </tr>
</table>
<br>

     There is a specific implementation of this logic in the AMS code. 
The main class, AMSEventR, inheriting all the TSelector functionality, 
is created as "class AMSEventR: public TSelector {...}".
The relevant features of the AMS implementation are:<br>

<ul>
   <li> The Begin(TTree* tree), ProcessCut(int entry), ProcessFill(int entry)
         and Terminate() methods are implemented
        in AMSEventR as methods that perform several operations and then call respectively:<br>
<table align=center>
  <tr>
   <td> <b>void UBegin() </b> </td>
  </tr>
  <tr>
   <td> <b>bool UProcessCut() </b> </td>
  </tr>
  <tr>
   <td> <b>void UProcessFill() </b> </td>
  </tr>
  <tr>
   <td> <b>void UTerminate() </b> </td>
  </tr>
</table>
<br>
        (note that the "int entry" and "TTree *tree" arguments have been dropped).  
        The intention is to have users calling UBegin(), 
        UProcessCut(), UProcessFill() and UTerminate() 
        in their analysis (and not Begin(tree), ProcessCut(entry),...).
        <br>
</ul>
<ul>
   <li> Using UProcessCut() is optional and it is included just for 
        convenience.  There is no gain in time by calling it. 
        The AMS implementation reads a header, not the full information. 
        The idea is that, since all information is "directly" accessed by 
        pointers, we are only spending time when we actually "pick up" the 
        contents inside UProcessFill().<br>
</ul>
<ul>
   <li> All the necessary definitions are in the AMS Root header file, 
        either "/offline/vdev/include/root.h" or "$AMSDir/include/root.h". 
        This header file must be always included in your analysis program.
</ul>
<ul>
   <li> In order to access in a simple way all relevant pieces of information 
        many useful definitions, via pointers and vectors, are implemented. For example, 
        the number of hits in ECAL is given by::<br>
             <center> <b> 
             cout << "#Ehits: " << nEcalHit() << endl; 
             </b> </center><br>
        The "i" Hit in ECAL belongs to the class EcalHitR, and it may be
        accessed either as:<br>
             <center> <b> EcalHitR hit = EcalHit(i); </b> </center><br>
        or via the pointer pEcalHit(i):<br>
             <center> <b> EcalHitR* phit = pEcalHit(i); </b> </center><br>
        A reference to the ith element is obtained as:
             <center> <b> EcalHitR* phit = &EcalHit(i); </b> </center><br>
        The full list of AMS classes and attributes can be found 
        <a href="http://ams.cern.ch/AMS/Analysis/hpl3itp1/root02/html/classes.html"> 
        HERE </a>. For instance, in 
        <a href="http://ams.cern.ch/AMS/Analysis/hpl3itp1/root02/html/classEcalHitR.html"> 
        EcalHitR </a> the first member is "Status", which can be accessed either as:<br>
             <center> <b> int stat = EcalHit(i).Status; </b> </center><br><br>
        or:
             <center> <b> int stat = pEcalHit(i)->Status; </b> </center><br><br>
</ul>

<p> Let us go to practice. To analyze AMS data with `compiled' code one needs two 
programs: a `steering' program and the `to-be-compiled' analysis program. An example of steering program is 
<a href="http://ams.cern.ch/AMS/Analysis/hpl3itp1/root02/html/run_8stlv_8C-source.html">
 run.stlv.C </a>, which will initialize some ROOT stuff, define input and output files 
and invoque "TTree::Process". An example of the 
actual 'analysis' program, containing the "real" stuff with the calls to
Ubegin(), UProcessCut(), UProcessFill() and UTerminate(), 
is <a href="http://ams.cern.ch/AMS/Analysis/hpl3itp1/root02/html/stlv_8C-source.html">
stlv.C </a>. Everything works together by doing "root run.stlv.C". If one wants to run in 
non-graphic mode and exiting root at the end of processing, do: "root -b -q run.stlv.C".

   Some final comments:

<ul>
   <li> Note that the "stlv" name is not mandatory. Everything will work equally well if 
        you change all "stlv" by "anything". For instance, you may want to write 
        "my_anal.C", "class my_anal" and "chain.Process("my_anal.C+")" where appropriate.
</ul>
<ul>
   <li> It is recommended to include in "stlv.C" a "root.h" file which 
        matches the "ntuple.so" library loaded in "run.stlv.C". In case
        of doubts, you may want to create your own "$AMSDir/lib/linux/icc/ntuple.so" library with 
        "cd $AMSDir/install; gmake shared" and include "$AMSDir/include/root.h".
</ul>
<ul>
   <li> If you are combining several Root files created with different versions of the 
        AMS code, try to use the latest versions for "ntuple.so" and "root.h" and, of 
        course, do not extract a given variable if it does not exist for some of the Root files. 
        ROOT is able to work consistently in the presence of different versions, 
        although it may give problems whenever "ntuple.so" and 
        "root.h" are older than the newest of the structure versions in your files.
</ul>

<CENTER>
<H2> <font color=red> `Interactive' Analysis </font> </H2>
</CENTER>

   <p>The file
<a href="http://ams.cern.ch/AMS/Analysis/hpl3itp1/root02/html/ana_8root_8C-source.html"> 
ana.root.C </a> shows an example of interactive running. To run it, do: 
"root ana.root.C". If you are already inside "root", use ".x ana.root.C".
Some comments are in order:

<ul>
      <li> One has to load the specific AMS Root library containing all the ROOT class
           definitions, class attributes and utilities. On Linux, you can always try:
              <CENTER><b>
              "gSystem->Load(/offline/vdev/lib/linux/icc/ntuple.so)". 
              </b></CENTER><br>
           In some specific cases, when
           you are modifying or developing code, you will prefer to use your own 
           library from your CVS directory $AMSDir. For that, you will need to 
           execute: 
              <CENTER><b>
              "cd $AMSDir/install; gmake shared" 
              </b></CENTER><br>
           and load instead with: 
              <CENTER><b>
              "gSystem->Load($AMSDir/lib/linux/icc/ntuple.so)". 
              </b></CENTER><br>
           For ALPHA machines, substitute "linux/icc" by "osf1" where necessary.
</ul>

<ul>
      <li> We can add several Root files with the AMSChain::Add("file") method. 
           The class AMSChain inherit all the methods of the TChain class, but 
           simplifies the life by hiding some AMS internal operations.
</ul>

<ul>
      <li> In the interactive approach, we need to use AMSEventR objects: <br> 
              <CENTER><b>
                 "AMSEventR* pev = ams.GetEvent()"
              </b></CENTER><br>
              <CENTER><b>
                 "AMSEventR* pev = ams.GetEvent(event_number)"
              </b></CENTER><br>
              <CENTER><b>
                 "AMSEventR* pev = ams.GetEvent(run_number, event_number)"
              </b></CENTER><br>
           If you prefer not to use a pointer "pev", you can add:
              <CENTER><b>
                 "AMSEventR &ev = *pev;"
              </b></CENTER><br>
           and use "ev" from that point on.
</ul>

<ul>
   <li> In order to access in a simple way all relevant pieces of information 
        many useful definitions, via pointers and vectors, are implemented. For example, 
        the number of hits in ECAL is given by::<br>
             <center> <b> 
             cout << "#Ehits: " << ev.nEcalHit() << endl; 
             </b> </center><br>
             or, alternatively:
             <center> <b> 
             cout << "#Ehits: " << pev->nEcalHit() << endl; 
             </b> </center><br>
        The "i" Hit in ECAL belongs to the class EcalHitR, and it may be
        accessed either as:<br>
             <center> <b> EcalHitR hit = ev.EcalHit(i); </b> </center><br>
        or via the pointer pEcalHit(i):<br>
             <center> <b> EcalHitR* phit = ev.pEcalHit(i); </b> </center><br>
        A reference to the ith element is obtained as:
             <center> <b> EcalHitR* phit = &ev.EcalHit(i); </b> </center><br>
        The full list of AMS classes and attributes can be found 
        <a href="http://ams.cern.ch/AMS/Analysis/hpl3itp1/root02/html/classes.html"> 
        HERE </a>. For instance, in 
        <a href="http://ams.cern.ch/AMS/Analysis/hpl3itp1/root02/html/classEcalHitR.html"> 
        EcalHitR </a> the first member is "Status", which can be accessed either as:<br>
             <center> <b> int stat = ev.EcalHit(i).Status; </b> </center><br><br>
        or:
             <center> <b> int stat = ev.pEcalHit(i)->Status; </b> </center><br><br>
</ul>

</BODY>
</HTML>
