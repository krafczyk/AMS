//  $Id: getior.pc,v 1.2 2002/03/25 16:54:37 alexei Exp $
//
// Subroutines to get IOR from AMS ORACLE database
//
//
// A.Klimentov  March   20, 2002. 
//
// Last Edit : March 20, 2002
//

#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <sys/times.h>
#include <strstream.h>
#include <iomanip.h>
#include <math.h>

#include <unistd.h>
#include <sys/stat.h>
#include <sys/file.h>



#include <sqlca.h>
#include <oraca.h>
#include <oracle.h>

//
//#define NON_EXISTENT  -942
//#define NOT_FOUND     1403
//#ifndef NULL
//#define NULL             0
//

int  verbose = 0;
int  output  = 0;
char ofile[256];

EXEC SQL BEGIN DECLARE SECTION;
//


  char     userpass[32];


  VARCHAR  dynstmt[2048];

  struct ior {
   char name[2048];
   unsigned int time;
  } iors[100];

EXEC SQL END DECLARE SECTION;

void Fmessage(const char *subr, const char *text, const char *errcode)
{
//
// subr -  subroutine name
// text -  message text
// errcode - 'I' / 'F' / 'W' etc
//
 if (subr && text) {
  cout<<"AMSOracle::"<<subr<<"-"<<errcode<<"-"<<text<<endl;
 }
}

void sql_error(char *msg)
{
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    Fmessage("sql_error",msg,"E");
    Fmessage("sql_error",sqlca.sqlerrm.sqlerrmc,"E");
    EXEC SQL ROLLBACK RELEASE;
    exit(1);
}

void sql_nothing(char *msg)
{
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    Fmessage("sql_error",msg,"W");
    Fmessage("sql_error",sqlca.sqlerrm.sqlerrmc,"W");
}

void sql_notfound(char *msg)
{
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    Fmessage("sql_notfound",msg,"W");
}


unsigned int getiors()
{
//
// return host id for given client id
//
 unsigned int hid = -1;


 EXEC SQL WHENEVER SQLERROR DO sql_nothing("ORACLE warning: AMSoracle::getIORS");

 EXEC SQL SELECT iors, createtime INTO :iors FROM servers WHERE status='Active' ORDER BY createtime DESC;
  int niors  = sqlca.sqlerrd[2];
  if (verbose) {
   cout<<"getiors -I- found "<<niors<<" IORS"<<endl;
   if (niors > 0) {
    time_t t = iors[0].time;
    cout<<"getiors -I- the last one dated "<<ctime(&t)<<endl;
   }
  }
  if (niors == 0)
    {
     strcpy(iors[0].name, "-- IORS not found in Servers ---");
  }
}

int oracle_connect()
{
  char line[256];



  EXEC SQL WHENEVER SQLERROR GOTO connect_error;

  strcpy(userpass,"amsdes/ams@amsdb");

  EXEC SQL CONNECT :userpass;
  if (verbose) {
   strcpy(line,"connected to amsdb");
   Fmessage("oracle_connect ", line,"I");
 }
   return 0;

connect_error :
   strcpy(line,"failed to connect to oracle as ");
   strcat(line,userpass);
   Fmessage("oracle_connect", line,"F");

   return -1;
}

int suppressBlanks(char* string)
{
  int rstat = -1;
  if (string > 0) {
        for (int j=strlen(string)-1; string[j]==' '; j--) {
           string[j] = '\0';
         }
    rstat = 1;
   }
   return rstat;
}

main(int argc, char* argv[]) 
{
  if (argc > 1) {
   for (int i=0; i<argc; i++) {
     if (strcmp(argv[i],"-o") == 0) {
      if (i+1 < argc) {
       cout<<"output file "<<argv[i+1]<<endl;
       output = 1;
       strcpy(ofile,argv[i+1]);
      } else {
       cout<<"Error - no output file "<<endl;
       exit(0);
      }
     }
     if (strcmp(argv[i],"-v") == 0) {
      verbose = 1;
     }
     if (strcmp(argv[i],"-h") == 0) {
      cout<<"getior : reads AMS Oracle Database and returns IORS for server with the latest CREATETIME"<<endl;
      cout<<"source ~/AMS/install/AMSoracle"<<endl;
      cout<<"./getior"<<endl;
      cout<<"-h : print help"<<endl;
      cout<<"-v : verbose mode"<<endl;
      cout<<"-o iorfile : write IOR to iorfile"<<endl;
      exit(0);  
     }
   }
  }
   EXEC SQL WHENEVER SQLERROR DO sql_error("ORACLE error:");
   if(oracle_connect() != 0) exit(1);
   getiors();
   suppressBlanks(iors[0].name);
   if (!output) {
     cout<<iors[0].name<<endl;
   } else {
    ofstream rfile(ofile,ios::out|ios::out);
    rfile.setf(ios::dec);
    rfile<<iors[0].name<<endl;
    rfile.close();
   }
   exit(0);
}

