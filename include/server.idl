#pragma prefix "ams.cern.ch"
module DPS{
   typedef unsigned long time;
  interface Client{

   enum RecordChange{Delete,Update,Create};
   enum ClientStatus{Lost,Unknown,Submitted,Registered,Active,TimeOut,Killed};
   enum ClientType{Generic,Server,Consumer,Producer,Monitor};
   enum ClientExiting{NOP,CInExit,SInExit,CInAbort,SInAbort,SInKill};
   enum HostStatus{NoResponse,LastClientFailed,OK};

    struct CID{
    string HostName;
    unsigned long uid;
    unsigned long pid;
    unsigned long ppid;
    ClientType   Type;
    ClientExiting Status;
    string Interface;
    };

    boolean sendId(inout CID id, in time TimeOut);      

   struct NominalClient{
    short MaxClients;
    float CPUNeeded; 
    short MemoryNeeded;
    string WholeScriptPath;
    string LogPath;
    string SubmitCommand;
   }; 



    struct ActiveRef{
      string IOR;
      string Interface;
      ClientType Type;
    }; 

    typedef sequence<ActiveRef> ARS;
    long getARS(in CID cid, out ARS ars, in long maxcid);

    struct ActiveClient{
     CID id;
     ARS ars; 
     time LastUpdate;
     time Start;
     ClientStatus Status;
   };
    typedef sequence<ActiveClient> ACS;
    
    void Exiting(in CID id, in string Error, in ClientExiting Status);



   struct NominalHost{
    string HostName;
    string Interface;
    string OS;
    short   CPUNumber;
    short   Memory;
    long    Clock;      
   };

   typedef sequence<NominalHost> NHS;



      
   
   struct ActiveHost{
      string HostName;
      string Interface;
      HostStatus Status;
      short ClientsRunning;
      short ClientsAllowed; 
      long ClientsProcessed;
      long ClientsFailed;
      long ClientsKilled;
      time LastUpdate;
   };

    typedef sequence<ActiveHost> AHS;
     
  };
 
  interface Producer: Client{

    enum RunStatus{ToBeRerun, Failed,Processing, Finished};
    enum DSTStatus{Success,InProgress,Failure};

    struct TDVTableEntry{
     unsigned long id;
     time Insert;
     time Begin;
     time End;
    };

    struct TDVName{
     string Name;
     unsigned long Size;
     unsigned long CRC;
     TDVTableEntry Entry;
     long DataMC;
     boolean Success;
    };  
    typedef sequence<TDVName> TDV;
    typedef sequence<unsigned long> TDVbody;
    long getTDV(in DPS::Client::CID cid,inout TDVName tdvname, out TDVbody body);
    void sendTDV(in DPS::Client::CID cid,in TDVbody tdv, inout TDVName tdvname );


    typedef sequence<TDVTableEntry> TDVTable; 
    long getTDVTable(in DPS::Client::CID cid,inout TDVName tdvname, in unsigned long Run, out TDVTable table);     
    


    struct CurrentInfo{
      unsigned long Run;
      long EventsProcessed;     
      long LastEventProcessed;
      long ErrorsFound;
      float CPUTimeSpent;
      RunStatus Status;
      string HostName;
    }; 
    void sendCurrentInfo(in CID id,in CurrentInfo ci); 
 


     struct RunEvInfo{
     unsigned long uid;
     unsigned long Run;
     long FirstEvent;
     long LastEvent;
     time TFEvent;
     time TLEvent; 
     long Priority;
     string FilePath;
     RunStatus Status;
     RunStatus History;
     string OutputDirPath;
     long DieHard;
     long UpdateFreq;
     time SubmitTime;
     unsigned long cuid;
     CurrentInfo cinfo;     
    };
    typedef sequence<RunEvInfo> RES;
    long getRunEvInfoS(in CID id, out RES res, inout unsigned long maxr); 
    void getRunEvInfo(in CID id, out RunEvInfo rv);
    void sendRunEvInfo(in RunEvInfo ri, in RecordChange rch);

    struct DST{
     time   Insert;
     time   Begin;
     time   End;
     long   Run;
     long   FirstEvent;
     long   LastEvent;
     long   EventNumber;
     DSTStatus Status;
     string Name;
    };    

    void sendNtupleEnd(in CID id, in DST ne, in RecordChange re); 
    typedef sequence<DST> DSTS;
    long getNtupleS(in CID id, out DSTS dsts);     

    struct EventStatusEnd{
     TDV body;
     DST dn;
    };
    void sendEventStatusEnd(in CID id, in EventStatusEnd ee, in RecordChange re); 
    
    
  };

  interface Server: Client{

    enum OpType{StartClient,KillClient,CheckClient,ClearStartClient,ClearKillClient,ClearCheckClient};

    struct CriticalOps{
     time TimeOut;
     OpType Action;
     time TimeStamp;
     ClientType Type;
     unsigned long id; 
    };

    void sendCriticalOps(in CID id, in CriticalOps op);
    void ping();
    boolean TypeExists(in DPS::Client::ClientType type);

    long getACS(in CID id, out ACS acl, inout unsigned long maxc);
    void sendAC(in CID id, inout ActiveClient ac,in RecordChange rc);


    boolean getNC(in CID cid, out NominalClient nc);

    boolean getNK(in CID cid, out NominalClient nc);

    long getNHS(in CID id, out NHS nhs);

    long getAHS(in CID id, out AHS ahl);

   };
  interface Monitor: Client{
  };
  
};
