#pragma prefix "ams.cern.ch"
module DPS{
   typedef unsigned long time;
  interface Client{
   enum AccessType{Any,LessThan,Self,AnyButSelf,GreaterThan};
   enum RecordChange{Delete,Update,Create};
   enum ClientStatus{Lost,Unknown,Submitted,Registered,Active,TimeOut,Killed};
   enum ClientType{Generic,Server,Consumer,Producer,Monitor};
   enum ClientExiting{NOP,CInExit,SInExit,CInAbort,SInAbort,SInKill};
   enum HostStatus{NoResponse,InActive,LastClientFailed,OK};

    struct CID{
    string HostName;
    unsigned long uid;
    unsigned long pid;
    unsigned long ppid;
    ClientType   Type;
    ClientExiting Status;
    string Interface;
    };

    boolean sendId(inout CID id, in time TimeOut);      
    void getId(out CID id);

   struct NominalClient{
    short MaxClients;
    float CPUNeeded; 
    short MemoryNeeded;
    string WholeScriptPath;
    string LogPath;
    string SubmitCommand;
    string HostName;
    short LogInTheEnd;
   }; 



    struct ActiveRef{
      string IOR;
      string Interface;
      ClientType Type;
    }; 

    typedef sequence<ActiveRef> ARS;
    long getARS(in CID cid, out ARS ars, in DPS::Client::AccessType type,in unsigned long id);

    struct ActiveClient{
     CID id;
     ARS ars; 
     time LastUpdate;
     time Start;
     ClientStatus Status;
   };
    typedef sequence<ActiveClient> ACS;
    typedef sequence<NominalClient> NCS;
    
    void Exiting(in CID id, in string Error, in ClientExiting Status);



   struct NominalHost{
    string HostName;
    string Interface;
    string OS;
    short   CPUNumber;
    short   Memory;
    long    Clock;      
   };

   typedef sequence<NominalHost> NHS;



      
   
   struct ActiveHost{
      string HostName;
      string Interface;
      HostStatus Status;
      short ClientsRunning;
      short ClientsAllowed; 
      long ClientsProcessed;
      long ClientsFailed;
      long ClientsKilled;
      time LastUpdate;
   };

    typedef sequence<ActiveHost> AHS;
     
  };
 
  interface Producer: Client{
    enum RunTransferStatus{Begin,Continue,End};
    enum RunStatus{ToBeRerun, Failed,Processing, Finished};
    enum DSTStatus{Success,InProgress,Failure};
    enum RunMode{RILO,LILO,RIRO,LIRO};
    enum DSTType{Ntuple,EventTag,RootFile};
    struct TDVTableEntry{
     unsigned long id;
     time Insert;
     time Begin;
     time End;
    };

    struct TDVName{
     string Name;
     unsigned long Size;
     unsigned long CRC;
     TDVTableEntry Entry;
     long DataMC;
     boolean Success;
    };  
    typedef sequence<TDVName> TDV;
    typedef sequence<unsigned long> TDVbody;
    long getTDV(in DPS::Client::CID cid,inout TDVName tdvname, out TDVbody body);
    void sendTDV(in DPS::Client::CID cid,in TDVbody tdv, inout TDVName tdvname );
    void sendTDVUpdate(in DPS::Client::CID cid, in TDVName tdvname );


    typedef sequence<TDVTableEntry> TDVTable; 
    long getTDVTable(in DPS::Client::CID cid,inout TDVName tdvname, in unsigned long Run, out TDVTable table);     
    


    struct CurrentInfo{
      unsigned long Run;
      long EventsProcessed;     
      long LastEventProcessed;
      long ErrorsFound;
      float CPUTimeSpent;
      RunStatus Status;
      string HostName;
    }; 
    void sendCurrentInfo(in CID id,in CurrentInfo ci); 

    struct DSTInfo{
     string HostName;
     string OutputDirPath;
     RunMode Mode;
     long UpdateFreq;
     long DieHard;
    };

     
     struct RunEvInfo{
     unsigned long uid;
     unsigned long Run;
     long FirstEvent;
     long LastEvent;
     time TFEvent;
     time TLEvent; 
     long Priority;
     string FilePath;
     RunStatus Status;
     RunStatus History;
     time SubmitTime;
     unsigned long cuid;
     CurrentInfo cinfo;     
    };
    typedef sequence<DSTInfo> DSTIS;
    long getDSTInfoS(in CID id, out DSTIS dsti);

    typedef sequence<RunEvInfo> RES;
    long getRunEvInfoS(in CID id, out RES res, inout unsigned long maxr); 
    void getRunEvInfo(in CID id, out RunEvInfo rv, out DSTInfo dv);
    void sendRunEvInfo(in RunEvInfo ri, in RecordChange rch);

    struct DST{
     time   Insert;
     time   Begin;
     time   End;
     long   Run;
     long   FirstEvent;
     long   LastEvent;
     long   EventNumber;
     DSTStatus Status;
     DSTType Type;
     string Name;
    };    

    void sendDSTEnd(in CID id, in DST ne, in RecordChange re); 
    typedef sequence<DST> DSTS;
    long getDSTS(in CID id, out DSTS dsts);     

    typedef sequence<octet> RUN;
    exception FailedOp{
     string message;
    };
    struct FPath{
     string fname;
     unsigned long pos;
    };  
    long getRun(in CID id, in FPath fpath ,out RUN run,  inout RunTransferStatus st) raises(FailedOp);      
    
  };

  interface Server: Client{

    enum OpType{StartClient,KillClient,CheckClient,ClearStartClient,ClearKillClient,ClearCheckClient};

    struct CriticalOps{
     time TimeOut;
     OpType Action;
     time TimeStamp;
     ClientType Type;
     unsigned long id; 
    };

    void sendCriticalOps(in CID id, in CriticalOps op);
    void ping();
    boolean TypeExists(in DPS::Client::ClientType type);

    long getACS(in CID id, out ACS acl, inout unsigned long maxc);
    void sendAC(in CID id, inout ActiveClient ac,in RecordChange rc);


    long getNC(in CID id, out NCS acl);
    long getNK(in CID id, out NCS acl);

    long getNHS(in CID id, out NHS nhs);

    long getAHS(in CID id, out AHS ahl);

   };
  interface Monitor: Client{
  };
  
};
