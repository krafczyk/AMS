
Thanks to Juan's courtesy there is no more dumb ntuple, only
clever one survived. No more nconvert.

Below there is a description of a  ntuple.

(!) New : Record Length = 8000


 ********************************************
* Type *    Range     *  Block   *  Name    *
 ********************************************               
* I*4  *              * EVENTH   * eventno          // Event no
* I*4  *              * EVENTH   * run              // run no
* I*4  *              * EVENTH   * runtype          //
* I*4  *              * EVENTH   * time(2)          // Event time
                                                    // (1) Unix time (sec)
                                                    // (2) usec time
* I*4  *              * EVENTH   * rawwords         // Event Lenght in bytes
* R*4  *              * EVENTH   * RadS             // Shuttle Altitude ( I2000 cm)
* R*4  *              * EVENTH   * ThetaS           // Shuttle Lattitude (GTOD rad)
* R*4  *              * EVENTH   * PhiS             // Shuttle phi (GTOD rad)
* R*4  *              * EVENTH   * YawS             // Shuttle yaw (LVLH rad) 
* R*4  *              * EVENTH   * PitchS           //         pitch
* R*4  *              * EVENTH   * RollS            //         roll
* R*4  *              * EVENTH   * VelocityS        // Shuttle speed (rad/sec)
                                                    // * -1  if dir is from north to south
* R*4  *              * EVENTH   * VelTheta         // speed theta (GTOD rad) 
* R*4  *              * EVENTH   * VelPhi           // speed phi (GTOD rad) 
* R*4  *              * EVENTH   * ThetaM           // Magnetic Latitude ***)
* R*4  *              * EVENTH   * PhiM             // Magnetic Longitude ***)
* I*4  *              * EVENTH   * Particles        // No of Particles
* I*4  *              * EVENTH   * Tracks           // No of Tracks                    
* I*4  *              * EVENTH   * Betas            // No of Betas
* I*4  *              * EVENTH   * Charges          // No of Charges
* I*4  *              * EVENTH   * TrRecHits        // No of 3 dim trackerpoints
* I*4  *              * EVENTH   * TrClusters       // No of Tr Clusters
* I*4  *              * EVENTH   * TrRawClusters    // No of Tr Raw Clusters
* I*4  *              * EVENTH   * TrMCClusters     // No of Tr MC hits
* I*4  *              * EVENTH   * TOFClusters      // No of TOF Clusters
* I*4  *              * EVENTH   * TOFMCClusters    // No of TOF MC Hits
* I*4  *              * EVENTH   * CTCClusters      // No of Cerenkov clusters
* I*4  *              * EVENTH   * CTCMCClusters    // No of Cerenkov MC hits
* I*4  *              * EVENTH   * AntiMCClusters   // No of Anti MC Hits
* I*4  *              * EVENTH   * AntiClusters     // No of Amti clusters
* I*4  *              * EVENTH   * EventStatus      // EventStatus (see status.doc)

* I*4  * [0,10]       * BETA     * nbeta             // betas number
* I*4  *              * BETA     * betastatus        // 4 - ambig
                                                        
                                              
* I*4  *              * BETA     * betapattern(nbeta) // beta pattern(beta.doc) 
* R*4  *              * BETA     * beta(nbeta)       // velocity
* R*4  *              * BETA     * betac(nbeta)       // corrected velocity
* R*4  *              * BETA     * betaerror(nbeta)  // est error  1/velocity 
* R*4  *              * BETA     * betaerrorc(nbeta)  // est error  1/corrected velocity 
* R*4  *              * BETA     * betachi2(nbeta)   // chi2 of beta fit(time)
* R*4  *              * BETA     * betachi2s(nbeta)  // chi2 of beta fit(space)
* I*4  *              * BETA     * betantof(nbeta)   // number of tof planes
* I*4  *              * BETA     * betaptof(4,nbeta) // pointers to tof planes
* I*4  *              * BETA     * betaptr(nbeta)    // pointer to track



* I*4  * [0,10]       * CHARGE   * ncharge            // charges number
* I*4  *              * CHARGE   * chargestatus       // 1 - refitted
* R*4  *              * CHARGE   * chargebetap(ncharge)   //pointer to velocity
* I*4  *              * CHARGE   * chargetof(ncharge)    // TOF charge
* I*4  *              * CHARGE   * chargetracker(ncharge) // Tracker Charge
* R*4  *              * CHARGE   * probtof(4,ncharge)    // TOF highest Probs
* I*4  *              * CHARGE   * chintof(4,ncharge)    // charge indices for highest Probs
                                                            charge.doc
* R*4  *              * CHARGE   * probtracker(4,ncharge) // Tracker highest Probs
* I*4  *              * CHARGE   * chintracker(4,ncharge) // charge indices for highest Probs
                                                            charge.doc
* R*4  *              * CHARGE   * proballtracker(ncharge)// Tracker highest Prob (all hits)
* R*4  *              * CHARGE   * truntof                // Trun (-1) mean (Anodes)
* R*4  *              * CHARGE   * truntofd               // Trun (-1) mean (Dynodes)
* R*4  *              * CHARGE   * truntracker            // Trun (-1) mean

* I*4  * [0,10]       * PARTICLE * npart                   // particles number
* I*4  *              * PARTICLE * pctcp(2,npart)    // pointer(s) to cerenkov
                                                     // cluster (matched)
* I*4  *              * PARTICLE * pbetap(npart)     // pointer to beta
* I*4  *              * PARTICLE * pchargep(npart)   // pointer to charge
* I*4  *              * PARTICLE * ptrackp(npart)    // pointer to track
* I*4  *              * PARTICLE * pid(npart)        // Geant Particle Id
* R*4  *              * PARTICLE * pmass(npart)      // particle mass 
* R*4  *              * PARTICLE * perrmass(npart)   // error in particle mass
* R*4  *              * PARTICLE * pmom(npart)       // particle momentum
                                                     //  (signed)
* R*4  *              * PARTICLE * perrmom(npart)    // error in momentum
* R*4  *              * PARTICLE * pcharge(npart)    // charge
* R*4  *              * PARTICLE * ptheta(npart)     // theta (1st(last) tracker plane)
* R*4  *              * PARTICLE * pphi(npart)       // phi  -----------
* R*4  *              * PARTICLE * thetagl(npart)    // theta global **)
* R*4  *              * PARTICLE * phigl(npart)      // phi global
* R*4  *              * PARTICLE * pcoo(3,npart)     // coo  -----------
* I*4  *              * PARTICLE * atcnbcel(2,npart) // nb of acrossed cells
* R*4  *              * PARTICLE * atcnbphe(2,npart) // nb of photoelectrons
* I*4  *              * PARTICLE * atcidcel(2,npart) // cells id
* I*4  *              * PARTICLE * atcdispm(2,npart) // PM minimal distance
* I*4  *              * PARTICLE * atcdaero(2,npart) // Aerogel path length
* I*4  *              * PARTICLE * atcstatu(2,npart) // Bad ATC cells
* R*4  *              * PARTICLE * atcbeta(npart)    // velocity from ATC
* R*4  *              * PARTICLE * cooctc(3,2,npart) // tracker extrapol in ctc
* R*4  *              * PARTICLE * cootof(3,4,npart) // tracker extrapol in tof
* R*4  *              * PARTICLE * cooanti(3,2,npart)// tracker extrapol in anti
* R*4  *              * PARTICLE * cootr(3,6,npart)  // tracker extrapol in tr


* I*4  * [0,20]       * TOFCLUST * ntof                // TOF clusters number
* I*4  *              * TOFCLUST * TOFStatus(ntof)  // Status: 
                                                    // bit 4 - ambig
                                                    // bit 128 -> problems with history
                                                    // bit 256 -> "1-sided" counter
                                                    // bit 512 -> bad t-measurement
                                                    //            on one of the sides
                                                    // bit 2048 -> recovered from 1-sided
                                                    //             (bit256 also set)
* I*4  *              * TOFCLUST * plane(ntof)         // Tof counter no
                                                       //1..4 up..down
* I*4  *              * TOFCLUST * bar(ntof)           //  TOF bar no
* R*4  *              * TOFCLUST * TOFEdep(ntof)      // TOF energy loss(MeV) from Anode
* R*4  *              * TOFCLUST * TOFEdepd(ntof)     // TOF energy loss(MeV) from Dynode
* R*4  *              * TOFCLUST * TOFTime(ntof)      // TOF time (sec)
* R*4  *              * TOFCLUST * TOFETime(ntof)     // Error in TOF time
* R*4  *              * TOFCLUST * TOFCoo(3,ntof)     // TOF Coo (cm)
* R*4  *              * TOFCLUST * TOFErCoo(3,ntof)   //
* I*4  *              * TOFCLUST * nmemb(ntof)        // Number of bars in cluster 


* I*4  * [0,200]      * TOFMCCLU * ntofmc            // TOF MC hits number
* I*4  *              * TOFMCCLU * TOFMCIdsoft(ntofmc)    // Idsoft
                                                       // Ask E. Choumilov
                                                       // if needed
                                                       //
* R*4  *              * TOFMCCLU * TOFMCXcoo(3,ntofmc)// coo
* R*4  *              * TOFMCCLU * TOFMCtof(ntofmc)   // time
* R*4  *              * TOFMCCLU * TOFMCedep(ntofmc)  // energy(meV) 
* I*4  * [0,50]       * TRCLUSTE * ntrcl              // Tracker clusters number
* I*4  *              * TRCLUSTE * Idsoft(ntrcl)     // Idsoft
                                                     // mod(id,10) layer 
                                                      // mod(id/10,100) ladder    
                                                     // i=mod(id/1000,10)
                                                      // i==0 x 1st half
                                                     // i==1 x 2nd half
                                                     // i==2 y 1st half
                                                     // i==3 y 2nd half
                                                     // id/10000 strip
* I*4  *              * TRCLUSTE * Statust(ntrcl)   // Status *)
* I*4  *              * TRCLUSTE * NelemL(ntrcl)    // -Number of strips left to max
* I*4  *              * TRCLUSTE * NelemR(ntrcl)    // Number of strips right to max 
* R*4  *              * TRCLUSTE * Sumt(ntrcl)      // Amplitude total
* R*4  *              * TRCLUSTE * Sigmat(ntrcl)    // Sigma total
* R*4  *              * TRCLUSTE * Meant(ntrcl)     // CofG (local)
* R*4  *              * TRCLUSTE * RMSt(ntrcl)      // RMS cluster
* R*4  *              * TRCLUSTE * ErrorMeant(ntrcl) // error in CofG
* R*4  *              * TRCLUSTE * Amplitude(5,ntrcl) // strips ampl


* I*4  * [0,200]      * TRMCCLUS * ntrclmc          // Tracker MC hits number
* I*4  *              * TRMCCLUS * IdsoftMC(ntrclmc) // Idsoft
                                                      // mod(id,10) layer
                                                      // mod(id/10,100) ladder
                                                      // id/1000 sensor
* I*4  *              * TRMCCLUS * Itra(ntrclmc)    // Particle Id (or 555 if noise)
* I*4  *              * TRMCCLUS * Left(2,ntrclmc)  // left strip no 
* I*4  *              * TRMCCLUS * Center(2,ntrclmc) // center strip no
* I*4  *              * TRMCCLUS * Right(2,ntrclmc)  // right stip no
* R*4  *              * TRMCCLUS * ss(5,2,ntrclmc)  // Strip amplitudes
* R*4  *              * TRMCCLUS * xca(3,ntrclmc)   // local input coo
* R*4  *              * TRMCCLUS * xcb(3,ntrclmc)  // local output coo
* R*4  *              * TRMCCLUS * xgl(3,ntrclmc)  // global coo
* R*4  *              * TRMCCLUS * summc(ntrclmc)  // total amplitude


* I*4  * [0,200]      * TRRECHIT * ntrrh          // tracker 3dim points number
* I*4  *              * TRRECHIT * px(ntrrh)     // pointer to x track clster
* I*4  *              * TRRECHIT * py(ntrrh)     //  --------  y --------
* I*4  *              * TRRECHIT * statusr(ntrrh) // Status *)
* I*4  *              * TRRECHIT * Layer(ntrrh)  // Layer no 1-6 up-down
* R*4  *              * TRRECHIT * hitr(3,ntrrh) // gl 3dim coordinates
* R*4  *              * TRRECHIT * ehitr(3,ntrrh) // error to above
* R*4  *              * TRRECHIT * sumr(ntrrh)    // Amplitude
* R*4  *              * TRRECHIT * difosum(ntrrh) (A_x-A_y)/(A_x+A_y)


* I*4  * [0,20]       * TRTRACK  * ntrtr          // tracks number
* I*4  *              * TRTRACK  * trstatus(ntrtr) // Status *)
* I*4  *              * TRTRACK  * pattern(ntrtr)  // Pattern (datacards.doc)
* I*4  *              * TRTRACK  * address(ntrtr)  // address (trrec.C buildaddress)

* I*4  *              * TRTRACK  * nhits(ntrtr)    // number of hits 
* I*4  *              * TRTRACK  * phits(6,ntrtr)  // pointers to trrechit
* R*4  *              * TRTRACK  * LocDbAver(ntrtr) // rel mom from testbeam
* I*4  *              * TRTRACK  * GeaneFitDone(ntrtr) // != 0 if done
* I*4  *              * TRTRACK  * AdvancedFitDone(ntrtr) --------------
* R*4  *              * TRTRACK  * Chi2StrLine(ntrtr) // chi2 sz fit
* R*4  *              * TRTRACK  * Chi2Circle(ntrtr) // chi2 circular fit
* R*4  *              * TRTRACK  * CircleRidgidity(ntrtr) // circular rigidity
* R*4  *              * TRTRACK  * Chi2FastFit(ntrtr) // chi2 fast nonl fit
* R*4  *              * TRTRACK  * Ridgidity(ntrtr) // fast nonl rigidity
* R*4  *              * TRTRACK  * ErrRidgidity(ntrtr) // err to 1/above
* R*4  *              * TRTRACK  * Theta(ntrtr) // theta (from fast)
* R*4  *              * TRTRACK  * phi(ntrtr)   // phi ---------
* R*4  *              * TRTRACK  * p0(3,ntrtr)  // coords ----------
* R*4  *              * TRTRACK  * gchi2(ntrtr) // geane chi2
* R*4  *              * TRTRACK  * gridgidity(ntrtr)// ------ rigidity
* R*4  *              * TRTRACK  * gerrridgidity(ntrtr) //error to 1/above
* R*4  *              * TRTRACK  * gtheta(ntrtr)// -------- theta
* R*4  *              * TRTRACK  * gphi(ntrtr)  // -------- phi
* R*4  *              * TRTRACK  * gp0(3,ntrtr) // ------ coords
* R*4  *              * TRTRACK  * hchi2(2,ntrtr) // two halves chi2s
* R*4  *              * TRTRACK  * HRidgidity(2,ntrtr) //-------- rigities
* R*4  *              * TRTRACK  * HErrRidgidity(2,ntrtr) // errors to 1/above
* R*4  *              * TRTRACK  * htheta(2,ntrtr) // ------- thetas
* R*4  *              * TRTRACK  * hphi(2,ntrtr) // ------ phis
* R*4  *              * TRTRACK  * hp0(3,2,ntrtr) // ------- coords
* R*4  *              * TRTRACK  * fchi2ms(ntrtr) // fast chi2 mscat off
* R*4  *              * TRTRACK  * gchi2ms(ntrtr) // geane chi2 mscat off
* R*4  *              * TRTRACK  * ridgidityms(ntrtr) // fast rigidity mscat off
* R*4  *              * TRTRACK  * gridgidityms(ntrtr) // geane rigidity mscat off
* I*4  * [0,20]       * MCEVENTG * nmcg // Number of input particles in MC gen
* I*4  *              *MCEVENTG  * nskip  //Pos no for test beam data or MC spec
* I*4  *              * MCEVENTG * Particle(nmcg) // Geant particle id
* R*4  *              * MCEVENTG * coo(3,nmcg)  // geant particle coos
* R*4  *              * MCEVENTG * dir(3,nmcg)  // ------- dir cos
* R*4  *              * MCEVENTG * momentum(nmcg) // momentum
* R*4  *              * MCEVENTG * mass(nmcg)   // mass
* R*4  *              * MCEVENTG * charge(nmcg) // charge


* I*4  * [0,20]       * CTCCLUST * nctccl    // cerenkov clusters number
* I*4  *              * CTCCLUST * CTCStatus(nctccl)  // Status *)
* I*4  *              * CTCCLUST * CTCLayer(nctccl)  // layer no
* R*4  *              * CTCCLUST * ctccoo(3,nctccl)  // coords
* R*4  *              * CTCCLUST * ctcercoo(3,nctccl) // errors to above
* R*4  *              * CTCCLUST * ctcrawsignal(nctccl) // raw signals
* R*4  *              * CTCCLUST * ctcsignal(nctccl) // corrected ones
* R*4  *              * CTCCLUST * ctcesignal(nctccl) // error to above

* I*4  * [0,200]      * CTCMCCLU * nctcclmc    // cerenkov mc hits number
* I*4  *              * CTCMCCLU * CTCMCIdsoft(nctcclmc) // Idsoft
                                                         // Ask E. Choumilov
                                                         // if needed
                                                         //
                                                         //
* R*4  *              * CTCMCCLU * CTCMCXcoo(3,nctcclmc) // coords
* R*4  *              * CTCMCCLU * CTCMCXdir(3,nctcclmc) // dir cos
* R*4  *              * CTCMCCLU * CTCstep(nctcclmc)     // step size (cm)
* R*4  *              * CTCMCCLU * ctccharge(nctcclmc)   // particle charge
* R*4  *              * CTCMCCLU * ctcbeta(nctcclmc)     // velocity
* R*4  *              * CTCMCCLU * ctcedep(nctcclmc)     // energy dep (MeV)


* I*4  * [0,16]       * ANTICLUS * nanti                 // Anti clusters number
* I*4  *              * ANTICLUS * AntiStatus(nanti)     // Status
* I*4  *              * ANTICLUS * AntiSector(nanti)     // Sector no(1-16)
* R*4  *              * ANTICLUS * AntiEdep(nanti)       // Energy dep (MeV)   
* R*4  *              * ANTICLUS * AntiCoo(3,nanti)      // Coo (cm)
* R*4  *              * ANTICLUS * AntiErCoo(3,nanti)    // Err to Coo
* I*4  * [0,200]      * ANTIMCCL * nantimc               // MC Anti hits number
* I*4  *              * ANTIMCCL * AntiMCIdsoft(nantimc) // idsoft 
* R*4  *              * ANTIMCCL * AntiMCXcoo(3,nantimc) // coo
* R*4  *              * ANTIMCCL * AntiMCtof(nantimc)    // Tof
* R*4  *              * ANTIMCCL * AntiMCedep(nantimc)   // energy dep (GeV)


 * I*4  * [0,2]       * LVL3     * nlvl3                 // lvl3trigger number 
 * I*4  *             * LVL3     * LVL3TOFTr(nlvl3)      // TOF Trigger
 * I*4  *             * LVL3     * LVL3AntiTr(nlvl3)     // Anti Trigger
 * I*4  *             * LVL3     * LVL3TrackerTr(nlvl3)  // TrackerTrigger
                                                         // 0  - initial state
                                                         // 1  - reject (p)
                                                         // 2  - Too many hits 
                                                         // 3  - No comb found
                                                         // 4  - >=2 comb found
                                                         // 5  - Reserved
                                                         // 6  - Reserved
                                                         // 7  - Accept (ap)
                                                         //+8  - Heavy Ion 
                                                         //+32 - Prescaled evts
 * I*4  *             * LVL3     * LVL3NTrHits(nlvl3)    // Number Tr Hits
 * I*4  *             * LVL3     * LVL3NPat(nlvl3)       // Number "Tracks" found
 * I*4  *             * LVL3     * LVL3Pattern(2,nlvl3)  // Pattern no
 * R*4  *             * LVL3     * LVL3Residual(2,nlvl3) // Aver Residual (cm)
 * R*4  *             * LVL3     * LVL3Time(nlvl3)       // Alg Time (sec)
 * R*4  *             * LVL3     * LVL3ELoss(nlvl3)      // Aver energy loss

 * I*4  * [0,1]       * LVL1     * nlvl1                 // lvl1trigger number
 * I*4  *             * LVL1     * LVL1LifeTime(nlvl1)   // DAQLifeTime *1000
                                                         // + 10000* (sum tof temperatutes (8 crates)
 * I*4  *             * LVL1     * LVL1TOFFlag(nlvl1)    // z from trigger
 * I*4  *             * LVL1     * LVL1TOFPatt(4,nlvl1)  // tof pattern
                                                         // low  16 bit  or
                                                         // high 16 bit and
 * I*4  *             * LVL1     * LVL1TOFPatt1(4,nlvl1) // Tof pattern z>1
                                                         // -------------

 * I*4  *             * LVL1     * LVL1AntiPatt          // antipattern



 * I*4  * [0,50]      * CTCHIT   * nctcht                // CTC Hits number
 * I*4  *             * CTCHIT   * CTChitStatus(nctcht)  //  ----  status
 * I*4  *             * CTCHIT   * CTChitLayer(nctcht)   //        layer  
 * I*4  *             * CTCHIT   * ctchitcolumn(nctcht)  //        column(x)
 * I*4  *             * CTCHIT   * ctchitrow(nctcht)     //        row(y)   
 * R*4  *             * CTCHIT   * ctchitsignal(nctcht)  //        signal (pe)



 * I*4  * [0,500]     * TRRAWCL  * ntrraw                // trrawcl num
 * I*4  *             * TRRAWCL  * rawaddress(ntrraw)    // see TRCLUSTE Idsoft
 * I*4  *             * TRRAWCL  * rawlength(ntrraw)     //  rawcl length
 * R*4  *             * TRRAWCL  * s2n(ntrraw)           // s/n for seed




 * I*4  * [0,32]      * ANTIRAWC * nantiraw                  // antirawcl num
 * I*4  *             * ANTIRAWC * antirawstatus(nantiraw)   // status
 * I*4  *             * ANTIRAWC * antirawsector(nantiraw)   //sector 1-16
 * I*4  *             * ANTIRAWC * antirawupdown(nantiraw)   //0 - up 1 -down
 * R*4  *             * ANTIRAWC * antirawsignal(nantiraw)   // (mev)

 * I*4  * [0,20]      * TOFRAWCL * ntofraw                   // tofrawclnum (used)
 * I*4  *             * TOFRAWCL * tofrstatus(ntofraw)       // status
 * I*4  *             * TOFRAWCL * tofrplane(ntofraw)        // tof plane1-4
 * I*4  *             * TOFRAWCL * tofrbar(ntofraw)          // tof bar 1-14
 * R*4  *             * TOFRAWCL * tofrtovta(2,ntofraw)      // anode time 
                                                             //over_thresh (ns)
 * R*4  *             * TOFRAWCL * tofrtovtd(2,ntofraw)      // dinode time
                                                             //over_thresh (ns)
 * R*4  *             * TOFRAWCL * tofrsdtm(2,ntofraw)       // A-noncorrected
                                                             //  side times
 * R*4  *             * TOFRAWCL * tofreda(ntofraw)       // Edep-A (mev)
 * R*4  *             * TOFRAWCL * tofredd(ntofraw)       // Edep-D (mev)
 * R*4  *             * TOFRAWCL * tofrtm(ntofraw)        // Time (ns)
 * R*4  *             * TOFRAWCL * tofrcoo(ntofraw)       // Long.coord.(cm)





---------------------------------------------------------------------------

*) Status bits (counting from 1 to 32)

 1 - REFITTED object                                     (status&1     !=0)
 2 - WIDE in shape (Tracker)                             (status&2     !=0)
 3 - AMBIGously associated                               (status&4     !=0)
 4 - RELEASED object                                     (status&8     !=0)
 5 - BAD                                                 (status&16    !=0)
 6 - USED as a component of a larger object              (status&32    !=0)
 7 - DELETED object                                      (status&64    !=0)
 8 - BADHIStory (TOF)                                    (status&128   !=0)
 9 - ONESIDE measurement (TOF)                           (status&256   !=0)
10 - BADTIME information (TOF)                           (status&512   !=0)
11 - NEAR, close to another object (Trck)                (status&1024  !=0)
12 - WEAK, defined with looser criteria (Trck)           (status&2046  !=0)
13 - AwayTOF, away from TOF predictions (Trck)           (status&4096  !=0)
14 - FalseX, x-coordinate built but not measured (Trck)  (status&8192  !=0)
15 - FalseTOFX, x-coordinates from TOF (Trck)            (status&16384 !=0)
16 - 4th tof plane was recovered using tracker           (status&32768 !=0)
17 - LocalDB was used to align track                     (status&65536 !=0)
18 - GlobalDB was used to align the track                (status&(65536*2)!=0)
19 - Cluster was used to get the charge                  (status&(65536*4)!=0)

**) AMS global system definition :
GTOD


***) Shuttle coordinates in an eccentric dipole coordinate system where
     GEOMz=-d, GEOMy=GEOMz x S  (d: dipole direction, S: geographic South)




stationr   is in I2000


