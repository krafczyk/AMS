
I. Proposed Daq Event format  (based on lebedev&capell 15/7/97)

All 16 bit unsigned integers. 32 & more bits are in little endian,i.e.
 unsigned short int ui16[2];
 integer r;
 ui16[0[=((unsigned integer)r)&65535;
 ui16[1]=(((unsigned integer)r)>>16)&65535;

 

   
-----------------------------------------------------------------------------
|EL|EID|HL|HID|Run(2)|AuxR|Event(2)|Time(4)|LSubDBl|IDSubDBl|..dataSubDBl.|
-----------------------------------------------------------------------------

Legend:

EL      - total length in 16 bit words   - 1    (mike idea)
EID     - Event ID = 0x0
HL      - header ==general run length - 1
HID     - header id = 1 << 9;
Run     - run number 32bit
AuxR    - run type   16bit
Evt     - event number 32bit
Time    - time 32bit unix format + 16bit tbd
LSubDBl - length of subdet block (LVL1,LVL3,TOF,Anti,Tracker,CTC)-1
IDSubDBl- id sub det block see below

(!) Header is not necessary follow the EID and should be find by id only.


II. Subdet event formats

a.Trig1 Event format

ID= 1 << 6 | 2<<9 
Word1   tof1 pattern 
Word2   tof2 pattern 
Word3   tof3 pattern 
Word4   tof4 pattern 
Word5   antipattern  
word6   z

b.Trig3 Event Format 

ID= 9 << 9 | {0,1,2,3,4,5} | <<6 
Word1 tracker  output 
Word2  8 bit tof output  +8 bit anti output
Word3 16 bit(signed) residual in mkm 
Word4  8 bit pattern + 8 bit nhits

c.TOF Event Format

 ----> Reduced format :
    one block consists of :
    
    Block_Length
    Block_id: 000 1010 nnn 000001   // nnn=0-7 is block(node) number
    TOF_data_SFET-1
    TOF_data_SFET-2
    TOF_data_SFET-3
    TOF_data_SFET-4
    
  where any TOF_data_SFET-n block has the following structure:
  
    hit_mask //16bits, always present, each bit means non-empty TDC channel 
    hit_counters // one 16bits word : 4x4bits hit-counters for first <=4 nonempty TDC channel
    TDC_value    // tdc-hits for first four non empty TDC channels
       .
       . 
    hit_counters // 4x4bits hit-counters for second <=4 nonempty TDC channel (if needed)
    TDC_value    // tdc-hits for second four non empty TDC channels
       .
       . 


  Each TDC_value is 16 bits word: bits (0-13)-> edge time, (14)->edge phase, (15)->reserved
  
 ----> Raw format: 
    one block consists of :

    Block_Length
    Block_id: 000 1010 nnn 000000   // nnn=0-7 is block(node) number
    header_word // Not final !!! : bits(12-15)->SFET_number(0-7); (8-11)->tdc_ch(0-15)
                                     bit(0)->phase_bit 
    TDC_value    
    
       .         // next pair of (header_word + TDC_value)
       .
    
    
d.Anti Event Format


To be defined


e. Reduced Tracker Event Format

ID = 1 | 2<<6 | 11 <<9 (x<0)   or    1 | 5<<6 | 11<<9 (x>0)
word1 8bit cluster length - 3 | 8bit max hit offset
word2 leftmost hit address
word 3 to length+3
amplitudes*8
.............



f.CTC(Aerogel) Event Format


To be defined





III. Interface with DAQEvent class

a. Daq->Raw conversion

Each subdetector or trigger class
should have at least two  functions 
(one pair for one specifiq daq format)
of the following form (names are not relevant)

 static integer checkdaqid(int16u id){return 1 if id is relevant else 0 }
  


 static void buildraw(integer length, int16u *p);  // builds raw from daq from p
                                                   //  p points to idsubdbl    
                                                   // length==LSubDBl      


b. Raw->Daq conversion

Each block type (block type = header, trig-1,3, tracker, scrate etc)
should have 3 functions
 
 static integer getmaxblocks();      // returns maxblocks
 static integer calcdaqlength(int i);    // i =0 to max blocks-1
                                     // return data length ==LSubDBl

 static void builddaq(integer i, integer length, int16u *p);
                                                 // builds daq from raw into p,
                                                 // i =0 to max blocks-1  
                                                 // p points to idsubdbl
                                                 // length==LSubDBl



The corresponding functions should be registered in AMSJob::_redaqinitjob()
as in example:


 //tracker

    DAQEvent::addsubdetector(&AMSTrRawCluster::checkdaqid,
                             &AMSTrRawCluster::buildraw, uinteger btype);

    DAQEvent::addblocktype(&AMSTrRawCluster::getmaxblocks,
                           &AMSTrRawCluster::calcdaqlength,
                           &AMSTrRawCluster::builddaq, uinteger btype);












IV. Relevant datacards 

    AMSJOB 1

    DAQC 

    (see datacards.doc)




    



V. Built in access to event header


runno()
eventno()
runtype()
time()

(Active only after _HeaderOK())

